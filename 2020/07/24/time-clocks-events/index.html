<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>分布式系统：与时间有关的故事 | 泠风 - Chad's blog</title><meta name="description" content="分布式系统：与时间有关的故事 世界就是一个分布式系统。  时序问题在分布式系统里面是个大问题。一直以来，时序问题在很多场合有点过于理论化，所以，大部分工程领域对这个问题关心得并不多，鲜有深入浅出的文章给出框架性的指引，我想尝试用一篇文章彻底理清分布式系统关于时间、时钟、时序、事件顺序相关的经典问题和解决方法（理论、设计等）。 时序问题：从生活到分布式系统时间是生活中一个很重要的概念，我们用时间确定"><meta name="keywords" content="分布式系统"><meta name="author" content="Chad Mai"><meta name="copyright" content="Chad Mai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.sunmxt.cn/2020/07/24/time-clocks-events/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="分布式系统：与时间有关的故事"><meta property="og:url" content="http://blog.sunmxt.cn/2020/07/24/time-clocks-events/"><meta property="og:site_name" content="泠风 - Chad's blog"><meta property="og:description" content="分布式系统：与时间有关的故事 世界就是一个分布式系统。  时序问题在分布式系统里面是个大问题。一直以来，时序问题在很多场合有点过于理论化，所以，大部分工程领域对这个问题关心得并不多，鲜有深入浅出的文章给出框架性的指引，我想尝试用一篇文章彻底理清分布式系统关于时间、时钟、时序、事件顺序相关的经典问题和解决方法（理论、设计等）。 时序问题：从生活到分布式系统时间是生活中一个很重要的概念，我们用时间确定"><meta property="og:image" content="http://blog.sunmxt.cn/img/space-time1.svg"><meta property="article:published_time" content="2020-07-24T02:50:27.000Z"><meta property="article:modified_time" content="2020-07-24T11:27:53.749Z"><meta name="twitter:card" content="summary"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="Begin? Maybe." href="http://blog.sunmxt.cn/2020/07/02/begin-maybe/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式系统：与时间有关的故事"><span class="toc-number">1.</span> <span class="toc-text">分布式系统：与时间有关的故事</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#时序问题：从生活到分布式系统"><span class="toc-number">1.1.</span> <span class="toc-text">时序问题：从生活到分布式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#经典问题：提交一笔电商交易"><span class="toc-number">1.1.1.</span> <span class="toc-text">经典问题：提交一笔电商交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题抽象"><span class="toc-number">1.1.2.</span> <span class="toc-text">问题抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happened-before-关系"><span class="toc-number">1.1.3.</span> <span class="toc-text">happened-before 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏序和全序"><span class="toc-number">1.1.4.</span> <span class="toc-text">偏序和全序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#因果关系"><span class="toc-number">1.1.5.</span> <span class="toc-text">因果关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理时钟（Physics-clock）"><span class="toc-number">1.2.</span> <span class="toc-text">物理时钟（Physics clock）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟漂移问题（Clock-Drift）"><span class="toc-number">1.2.1.</span> <span class="toc-text">时钟漂移问题（Clock Drift）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟同步：NTP协议"><span class="toc-number">1.2.2.</span> <span class="toc-text">时钟同步：NTP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当时钟开了挂：GPS、原子钟与-TrueTime-API"><span class="toc-number">1.2.3.</span> <span class="toc-text">当时钟开了挂：GPS、原子钟与 TrueTime API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中心授时：Timestamp-Oracle（TSO）"><span class="toc-number">1.2.4.</span> <span class="toc-text">中心授时：Timestamp Oracle（TSO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TiKV-的实践：混合时钟，TSO-LC"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">TiKV 的实践：混合时钟，TSO+LC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑时钟（Logical-Clock）"><span class="toc-number">1.3.</span> <span class="toc-text">逻辑时钟（Logical Clock）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lamport-时钟"><span class="toc-number">1.3.1.</span> <span class="toc-text">Lamport 时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#人为定义的全序"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">人为定义的全序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向量时钟（Vector-Clock）"><span class="toc-number">1.3.2.</span> <span class="toc-text">向量时钟（Vector Clock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合逻辑时钟（HLC，Hybird-Logical-Clock）"><span class="toc-number">1.3.3.</span> <span class="toc-text">混合逻辑时钟（HLC，Hybird Logical Clock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自稳定问题"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">自稳定问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局一致性快照（Globally-Consistent-Snapshots）"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">全局一致性快照（Globally Consistent Snapshots）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HLC-的优势"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">HLC 的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文献-References"><span class="toc-number">2.</span> <span class="toc-text">参考文献 References</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/space-time1.svg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">泠风 - Chad's blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">分布式系统：与时间有关的故事</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-07-24 02:50:27"><i class="far fa-calendar-alt fa-fw"></i> Created 2020-07-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-07-24 11:27:53"><i class="fas fa-history fa-fw"></i> Updated 2020-07-24</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>Comments:</span><a href="/2020/07/24/time-clocks-events/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/07/24/time-clocks-events/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="分布式系统：与时间有关的故事"><a href="#分布式系统：与时间有关的故事" class="headerlink" title="分布式系统：与时间有关的故事"></a>分布式系统：与时间有关的故事</h1><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>世界就是一个分布式系统。</p>
</blockquote>
<p>时序问题在分布式系统里面是个大问题。一直以来，时序问题在很多场合有点过于理论化，所以，大部分工程领域对这个问题关心得并不多，鲜有深入浅出的文章给出框架性的指引，我想尝试用一篇文章彻底理清分布式系统关于时间、时钟、时序、事件顺序相关的经典问题和解决方法（理论、设计等）。</p>
<h2 id="时序问题：从生活到分布式系统"><a href="#时序问题：从生活到分布式系统" class="headerlink" title="时序问题：从生活到分布式系统"></a>时序问题：从生活到分布式系统</h2><p>时间是生活中一个很重要的概念，我们用时间确定事件的先后关系，进一步使得许多事情得以确定。举个例子，某天，我想请我的朋友帮忙代取快件，首先向朋友发起请求，朋友接收请求并同意后，才有取快件这一件事发生。例子中，“向朋友发起请求”是一个事件，“朋友取快件”又是另一个事件。上面事件必有严格的先后顺序，确定先后顺序除了根据逻辑推理，有时候我们还会记录事件的时间，以确定先后顺序。就不可能出现朋友先帮我取了快件，我再向朋友发出请求这种诡异的顺序，同时事件之间也是有因果关系的。</p>
<p>分布式系统也是类似的。很多时候，我们希望根据事件的先后关系确定系统表现出来的行为，使得设计的分布式系统是符合预期的。在日常生活潜移默化的影响下，我们也希望用时间解决这一问题。遗憾的是，利用时间确定分布式系统中的事件顺序并不容易。</p>
<h3 id="经典问题：提交一笔电商交易"><a href="#经典问题：提交一笔电商交易" class="headerlink" title="经典问题：提交一笔电商交易"></a>经典问题：提交一笔电商交易</h3><p>为了方便水平扩容，以支撑持续增长的业务量，一个大型、成熟的的电商系统很多时候会采用微服务系统架构。微服务设计下，原本为单体的系统，会根据功能、开发人员等，被拆分为一个个独立的<strong>微服务（Microservices）</strong>，微服务之间使用 <strong>RPC（远程过程调用，Remote Procedure Call）</strong>通信，各司其职为用户提供完整的电商交易平台。假设我们的电商平台包括了以下几个服务：</p>
<ul>
<li>业务服务：面向用户，提供操作接口（如：订单提交、购物车、商品搜索等）。</li>
<li>支付服务：接收其他服务发起的支付请求，为用户订单完成一整套支付过程（三方支付、完成银行支付等）。</li>
<li>订单服务：接收、跟踪、管理用户订单。</li>
<li>库存服务：商品的库存管理。</li>
</ul>
<p>你看这不，一只🐦，呃不，一个用户来下单了，向我们的系统发起了一笔交易。此时电商系统发生的事情可能是这样的：</p>
<ul>
<li>业务服务的 API 被用户终端调用（$A$ 事件）。</li>
<li>业务服务发起订单创建（$B $事件）。订单服务收到业务服务发起订单创建请求（$C$ 事件）。</li>
<li>订单服务向库存服务发起调用（$D $事件），要求扣减商品库存。</li>
<li>库存服务收到扣减库存请求（$E$ 事件），扣减了商品库存。</li>
<li>订单服务创建一笔订单（$ F$事件）。</li>
<li>调用返回后，业务服务向支付服务发起一笔支付，将用户导向到支付系统。</li>
<li>用户完成支付，支付系统通知订单服务，更新订单状态，并将用户导回业务服务。至此完成了一笔交易。</li>
</ul>
<p>对于每一笔订单，用日志追踪提交过程是重要的，可以便于了解系统的工作状况。我们希望日志顺序能够和事件发生的顺序一致，忠实反映系统的状态变更。进一步，如果我们期望在某些错误发生时，利用操作日志回滚整个系统的状态，确定事件的顺序就更加重要了。</p>
<h3 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h3><p>上面的电商系统本质是分布式系统。每个系统都可以看作一个独立的<strong>进程（Process）</strong>。进程间相互通信，一定会通过网络相互传递<strong>消息（Message）</strong>。一个进程可以发送消息、接收消息和完成自己的工作职责。由此上面系统的事件可以归为三类：发送、接收、自发。RPC调用方发生消息发送事件（如事件B、D），被调用方会发生接收事件（如事件C、E）。还有另外一类事件是自发事件，由进程自身运行产生（如事件F）。我们需要一种方法，准确刻画事件之间先后顺序，从而得到事件的全局排列。抽象出这样的模型后，某个分布式系统时序图可能是这样的：</p>
<p><img src= "/img/loading.gif" data-src="/img/space-time1.svg" alt="时序图1"></p>
<h3 id="happened-before-关系"><a href="#happened-before-关系" class="headerlink" title="happened-before 关系"></a>happened-before 关系</h3><p>对于两个不同的事件 $A$、$B$ ，如果 $A$ 发生在 $B$ 之前，我们引入一个记号”$\rightarrow$”去描述这样的先后关系，记作为 $A \rightarrow B$，意为 $A \text{ happened before } B$ 。对于这种关系，以下事实是显然的：</p>
<ul>
<li>进程内：如果事件 $A$ 和事件 $B$ 都发生在同一个进程内，而且事件 $A$ 先于事件 $B$ 发生，则有 $A \rightarrow B$。</li>
<li>进程间：显然任何一条消息都应是应该是“先发送，后接收”的，如果事件 $A$ 是一个进程引起的消息发送事件，事件 $B$ 是对应进程对该消息的接收事件，有 $A \rightarrow B$。</li>
<li>传递性：如果  $A \rightarrow B$ 且 $B \rightarrow C$，显然 $A \rightarrow C$。</li>
</ul>
<p>如果不同事件 $A$、$B$ 无法比较先后关系，我们表示为 $A \nrightarrow B$  且 $B \nrightarrow A$，我们说事件是<strong>并发的（Concurrent）</strong>。</p>
<p>特殊的，讨论任意事件与它本身的顺序关系是没有任何意义的。对于任意事件$A$，我们规定 $A \nrightarrow A$。</p>
<p>根据上面的图，举几个例子：</p>
<ul>
<li>$B_3 \rightarrow B_5$ （进程内）</li>
<li>$A_1 \rightarrow B_2$ （进程间）</li>
<li>$A_1 \rightarrow C_3$ （因为$A_1 \rightarrow B_2$ ，$B_2 \rightarrow B_3$，$B_3 \rightarrow B_4$，$B_4 \rightarrow C_3$，根据传递性）</li>
</ul>
<p><strong>happened-before 关系</strong>定义了分布式系统事件的最小粒度关系。</p>
<h3 id="偏序和全序"><a href="#偏序和全序" class="headerlink" title="偏序和全序"></a>偏序和全序</h3><p>一个分布式系统一段时间内发生的所有事件，可以组成一个事件集合 $S$。可以根据事件的 happened-before 关系对集合内事件进行排序，得出类似 $A \rightarrow B \rightarrow C \rightarrow D$ 的次序关系，这种一般称作事件的<strong>序（Ordering）</strong>。</p>
<p>上面我们提到：并不是随意两个事件都能比较先后关系。我们假设事件集合 $S$ 中有事件$A$、$B$、$C$和$D$，且：</p>
<ul>
<li>$A \rightarrow B$</li>
<li>$B \rightarrow C$</li>
<li>$B \rightarrow D$</li>
</ul>
<p>我们可以得到事件的两个序：</p>
<ul>
<li>$A \rightarrow B \rightarrow C$</li>
<li>$A \rightarrow B \rightarrow D$</li>
</ul>
<p>集合中存在两个事件 $C$ 和 $D$ 无法确定先后顺序，于是只能定出事件的部分顺序，定出的这种顺序称作<strong>偏序（Partial Ordering）</strong>。</p>
<p>如果我们上面的情况下，确定了$C \rightarrow D$，就可以得到 $A \rightarrow B \rightarrow C \rightarrow D$ ，集合中所有事件的顺序都确定了，这种情况给出了事件的<strong>全序（Totally Ordering）</strong>。</p>
<p>我们来看上面的时序图，很显然我们只能确定偏序关系：</p>
<ul>
<li>$A_1 \rightarrow B_2 \rightarrow B_3 \rightarrow B_4 \rightarrow C_3 \rightarrow C_4$</li>
<li>$B_1 \rightarrow B_2 \rightarrow B_3 \rightarrow B_4 \rightarrow C_3 \rightarrow C_4$</li>
<li>$C_1 \rightarrow C_2 \rightarrow B_7$</li>
<li>…</li>
</ul>
<p>显然我们没法确定：</p>
<ul>
<li>$A_1$、$B_1$、$C_1$</li>
<li>$C_1$、$B_3$</li>
<li>…</li>
</ul>
<h3 id="因果关系"><a href="#因果关系" class="headerlink" title="因果关系"></a>因果关系</h3><p>事件的 happened-before 并不仅仅是为了追踪事件的序，里面还隐含着因果性。比如上面提交电商交易订单的例子中，终端调用引起业务服务发起订单创建，订单创建请求引发了库存扣减，进而又引发分布式系统中一系列的状态改变。一个事件引起了另一个事件的发生，事件间存在<strong>因果关系（Causal relationship）</strong>，捕捉这种因果关系对于维持分布式系统的一致性相当重要（毕竟我们不希望发生“订单创建了，但库存没扣减”或者“库存扣减了，订单没创建”等等奇奇怪怪的情况）。至于这个系统的容错问题或者怎么保证业务一致性，那就是另一个故事了。这里我们仅仅关注如何捕捉事件间的因果关系。</p>
<p>如果事件 $B$ 是事件 $A$ 的结果，换句话说事件 $A$ 导致了事件 $B$ 的发生，我们可以知道 $B$ 一定发生在 $A$ 之后：</p>
<script type="math/tex; mode=display">
(A \text{ affects } B) \Rightarrow (A \rightarrow B)</script><p>注意这里只用了 $\Rightarrow$，而不是 $\Leftrightarrow$ ，有些事件并不受前面发生的事件的影响，但它们却是存在先后顺序，所以反推是不一定成立的。从这个关系我们可以知道：<strong>事件间的因果关系包含在 happened-before 关系里。</strong></p>
<h2 id="物理时钟（Physics-clock）"><a href="#物理时钟（Physics-clock）" class="headerlink" title="物理时钟（Physics clock）"></a>物理时钟（Physics clock）</h2><blockquote>
<p>时间就是我的朋友。 —- 不知道谁说的</p>
</blockquote>
<p>至此，我们都是以上帝视角观察整个系统。回到最初的问题：我们想设计一个机制，让系统自己忠实记录事件顺序。我们是怎么比较两个事件的先后顺序的？生活的经验告诉我们，比较两个事件发生的时间就可以了。所以我们也想在分布式系统上这样干，我们使用<strong>物理时钟（Physics clock）</strong>把所有事件打上一个<strong>时间戳（Timestamp）</strong>。嗯，似乎很简单呢。其实不然。</p>
<h3 id="时钟漂移问题（Clock-Drift）"><a href="#时钟漂移问题（Clock-Drift）" class="headerlink" title="时钟漂移问题（Clock Drift）"></a>时钟漂移问题（Clock Drift）</h3><p>一个理想的分布式系统，各节点时间都是一致的。然而现实是复杂的，分布式系统各节点的时钟走时存在着飘移问题（上帝：“躺平？想的美。”）。一般计算机把时间存储在BIOS配置里，靠晶振输出稳定频率的振荡信号完成计时，晶振材料一般是石英。石英有温漂，换句话说就是工作温度影响到石英的震荡频率，除此之外石英还受到老化、电压的影响，种种因素使得振荡频率变高或变低了。这种效应间接导致的就是本地时钟走时变快或变慢了，而且这种走时误差会逐渐积累，达到分钟级，小时级，甚至天级。</p>
<p>我们最初想用节点的本地时钟为事件打上事件戳，这种做法下，一旦分布式系统节点间的时钟有了误差，我们就可能错判事件顺序关系，可能导致灾难性的后果。</p>
<h3 id="时钟同步：NTP协议"><a href="#时钟同步：NTP协议" class="headerlink" title="时钟同步：NTP协议"></a>时钟同步：NTP协议</h3><p>既然走时会有偏差，我们就尝试把误差消掉吧。NTP协议能取得一些效果。NTP 协议是一个 Server/Client 协议。为了和授时服务器同步时间，NTP Client 会定时轮询一个或多个 NTP Server。算法是这样的：</p>
<p>客户端假设比服务端时间快$\Delta t$，客户端发送NTP请求的事件戳为 $T_1$，服务端接收NTP请求的时间戳为 $T_2$，服务端回复 NTP 请求的事件戳为 $T_3$，客户端接收到 NTP 回复的事件戳为 $T_4$。$d_1$、$d_2$ 是请求和回复的网络时延，$d$ 是 RTT（round-trip time）。整个关系如下图：</p>
<p><img src= "/img/loading.gif" data-src="/img/ntp-roundtrip.svg" alt="NTP Roundtrip"></p>
<p>我们再假设 $d_1 = d_2$，就可以得到一个四元一次方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
T_2 = T_1 + \Delta t + d_1 \\
T_4 = T_3 - \Delta t + d_2 \\
d = d_1 + d_2 \\
d_1 = d_2
\end{matrix}\right.</script><p>解出关键两个参数：</p>
<script type="math/tex; mode=display">
\left \{ \begin{align}
\Delta t = \frac{(T_2-T_1) - (T_4 - T_3)}{2} \\
d = (T_2-T_1) + (T_4 - T_3)
\end{align}\right.</script><p>客户端根据结果进行时钟校正即可。因为前提假设是$d_1 = d_2$，NTP结果受到时延对称性和其他因素的影响，实际上应用中常有毫秒级的时延，跨数据中心的 NTP 同步误差可达上百毫秒，网络状况不好的情况下，可能会达到秒级。NTP 协议也并不对误差范围做任何保证（只是保证漂得不那么狠）。种种限制下，NTP时钟同步方案时钟漂移问题，解决得并不是很好。</p>
<h3 id="当时钟开了挂：GPS、原子钟与-TrueTime-API"><a href="#当时钟开了挂：GPS、原子钟与-TrueTime-API" class="headerlink" title="当时钟开了挂：GPS、原子钟与 TrueTime API"></a>当时钟开了挂：GPS、原子钟与 TrueTime API</h3><p>时钟漂移问题的本质其实是硬件不给力。Google 说：那我们从硬件下手吧。<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">Google Spanner</a> 是个全球性的分布式数据库，作为 Google F1 的存储层，在全球范围内跨数据中心部署，能提供强一致性事务。为了提供外部一致（Externally consistent）的分布式事务、无锁的只读事务，还有原子化的数据 Schema 更新，Spanner 用 TrueTime API 授时，用事件定序，解决分布式的事务顺序问题。</p>
<p>Google 在全球的每个数据中心都部署了授时服务，它们由多台叫做 Time Master 的机器组成。大多数 Time Master 从 GPS 同步时间，并且分布部署在不同地方防止天线信号问题。剩余的 Master 内部使用原子钟保证走时准确，Google 说原子钟并不贵（^_^，手动狗头）。所有 Time Master 会相互校时，也会比较走时速率，一旦发现自身偏差过大，就把自己从集群里“踢掉”。数据中心的每一台服务器都会运行 Timeslave Daemon。Daemon 不断轮询 Master 进行时钟同步，并提供了 TrueTime API 给应用使用。关于设计的更多细节，可以去读一下 TrueTime 相关论文。</p>
<p>通过这样一种方法，TrueTime 保证了本地获取的时钟戳的误差 $\epsilon$ （Uncertainty）总在可估计的确定范围内，当然这个误差非常小，在微秒到数毫秒。TrueTime API 提供了这样的一组接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ TT.now() $</td>
<td>$TTinterval: [earliest, latest]$</td>
</tr>
<tr>
<td>$TT.after(t)$</td>
<td>True if $t$ has definitely passed</td>
</tr>
<tr>
<td>$TT.before(t)$</td>
<td>True if $t$ has definitely not arrived</td>
</tr>
</tbody>
</table>
</div>
<p>因为有误差 $\epsilon$ ，$TT.now()$ 返回的是一个时间的区间 $TTinterval$，绝对时刻一定会在 $[earliest, latest]$ 内。如果有一个事件 $A$ ，$tt = TT.now()$，那么 <script type="math/tex">tt.earlist \le t_{abs}(E_{now}) \le tt.latest</script>。此处的  <script type="math/tex">t_{abs}(e)</script> 指的是理论上的绝对时刻，<script type="math/tex">E_{now}</script> 是 $TT.now()$​ 的发起（invocation）事件。</p>
<p>对于另外两个API。使用 $TT.after(t)$ 能保证时刻 $t$ 一定已经过去，使用 $TT.after(t)$ 能保证时刻 $t$ 一定还没有到来。它们分别等价于 <script type="math/tex">t_{abs}(E_{now}) \gt TT.now().latest</script> 和 <script type="math/tex">t_{abs}(E_{now}) \lt TT.now().earliest</script>。</p>
<p>对于两个事件 $A$、$B$，一定有：</p>
<script type="math/tex; mode=display">
(tt_A.latest \le tt_B.earliest) \Rightarrow (A \rightarrow B)</script><p>看起来似乎有可能定出事件的全序，然而实际上并不。因为不是所有事件都能满足条件，我们考虑到两个 $TTinterval$ 区间存在重叠的情况，这种情况下就无法定序了。 TrueTime 看似还有缺陷，但又不是不能用。</p>
<p><img src= "/img/loading.gif" data-src="/img/not-worse-to-be-useless.jpg" alt="又不是不能用"></p>
<p>实话说，因为保证了时间的 Uncertainty（而且很小），所以  TrueTime API 其实是个相当大的改进。我们粗略看一下 Spanner 是如何使用 TrueTime 来为写<strong>事务（Transaction）</strong>定序的（不感兴趣直接跳到 TSO 中心授时吧）。</p>
<p>Spanner 为每一个写事务都分配了一个时间戳 $s$，事件戳是单调递增的，并保证若事务 $T_2$ 比事务 $T_1$ 先开始，那么 $s_1 &lt; s_2$ ，其通过事件定序解决：</p>
<ul>
<li><p>Commit Wait 保证：第一个事务的真正 commit 时间 $t_{abs}(E_1^{commit})$ 一定比 $s_1$ 要晚。</p>
</li>
<li><p>Assumption：第二个事务的绝对开始时间 <script type="math/tex">t_{abs}(E_2^{start})</script>，不能小于前一个事务的 commit 绝对提交时间 <script type="math/tex">t_{abs}(E_1^{commit})</script></p>
</li>
<li>Start Guarantee：事务的事件戳不能小于其 Commit 请求到达服务器的绝对时间 $t_{abs}(E_2^{server})$</li>
</ul>
<p>于是呼：</p>
<p><img src= "/img/loading.gif" data-src="/img/huhuhu.jpg" alt="又不是不能用"></p>
<script type="math/tex; mode=display">
\begin{align}
s_1 &< t_{abs}(E_1^{commit}) && (\text{Commit Wait}) \\
t_{abs}(E_1^{commit}) &\le t_{abs}( E_2^{start}) && (\text{Assumption}) \\
t_{abs}(E_2^{start}) &\le t_{abs}( E_2^{server} ) && (E_2^{start} \rightarrow E_2^{server} )\\
t_{abs}(E_2^{server}) &\le s_2 && (\text{Start Guarantee})\\
s_1 &< s_2 && (\text{传递性}) \\
\end{align}</script><p>所以 TrueTime，可以说开了挂，这个挂叫 “GPS和原子钟”，把分布式数据库头疼了很久的一致性问题给解决了，更多细节参考 Spanner 相关论文吧。</p>
<h3 id="中心授时：Timestamp-Oracle（TSO）"><a href="#中心授时：Timestamp-Oracle（TSO）" class="headerlink" title="中心授时：Timestamp Oracle（TSO）"></a>中心授时：Timestamp Oracle（TSO）</h3><p>Lamport 在其主页<a href="https://lamport.azurewebsites.net/pubs/pubs.html#time-clocks" target="_blank" rel="noopener">介绍</a>自己的论文《Time, Clocks, and the Ordering of Events in a Distributed System》时与狭义相对论联系在了一起，表示自己从狭义相对论得到了灵感，似乎道出了分布式系统事件难以确定全序的本质原因：</p>
<blockquote>
<p>Special relativity teaches us that there is no invariant total ordering of events in space-time; different observers can disagree about which of two events happened first.  —- Leslie Lamport</p>
</blockquote>
<p>狭义相对论里面有个概念：相对同时。指的是：在一个参考系中同时发生的两个事件，在另一个参考系看来是不同时的。举个例子，如果都基于本地时间，地面上观测事件 $A$ 先于事件 $B$ 发生，但由于相对论效应，飞船上观测结论却可能截然相反。所以 Lamport 说相对论指出了：世界上根本无绝对唯一的事件全序关系，至于谁先发生，取决于观测者。这样看来，基于物理时钟来讨论事件的序根本毫无意义，这导致了 Lamport 决定脱离物理时钟，从另一个角度去看待事件的序，这个方法就是逻辑时钟（我们下面再讨论）。然而在分布式系统设计上，即使我们有一堆观测者（节点），很多时候也必须全局定序，使得所有观测者对于事件顺序必须达成一致，否则我们就很难设计系统，也很难去定义和解决一致性问题。既然多观测者下，难以全局定序，那么我们工程上折中一点，只用某个观测者看到的事件序作为全局的序，这样事情不就变得简单了吗？这种方法就是中心授时法。</p>
<p>Timestamp Oracle（TSO）是 Google 的 Percolator 分布式事务系统里依赖的授时服务的名称，因为 Percolator 事务模型过于知名，TSO 在很多情况下已经成为了中心授时的代称。关于 Percolator，有兴趣可以去读一读<a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36726.pdf" target="_blank" rel="noopener">论文</a>，非常有意思。</p>
<p>中心授时比较简单，当需要确定事件时刻，进而定序的时候，就向授时中心索要一个时间戳。因为我们舍弃了别的观测者看到事件序，授时中心看到的顺序才是权威，对于网络中消息延迟、乱序所造成的事件顺序错乱，就要小心解决。这样事件最终也能规定出全序。</p>
<p>中心授时带来的是单点问题，不太利于扩展，不过有 workaround。</p>
<h4 id="TiKV-的实践：混合时钟，TSO-LC"><a href="#TiKV-的实践：混合时钟，TSO-LC" class="headerlink" title="TiKV 的实践：混合时钟，TSO+LC"></a>TiKV 的实践：混合时钟，TSO+LC</h4><p>对于 TSO 中心授时，TiKV 作了改进。TiKV 通过 PD（Placement Driver） 进行授时，使用64位事件戳，物理时钟和逻辑时钟分别占 46 位和 18 位，本质是中心式的混合逻辑时钟。</p>
<p>PD 首先使用 raft 选举出 leader，进而进行校时。校时过程确定系统的时间到底被推进到了哪里，从 etcd 里先获取上一个 Leader 分配的最大时间 <script type="math/tex">t_{last}</script>，然后与本地时间进行比较，两者取大值。如果取的是<script type="math/tex">t_{last}</script>，那么将时间戳物理部分向前推进1，保证即将分配时间戳一定在已经分配的时间戳之后，完成校时。</p>
<p>PD 每次都会向 etcd 分配一个时间窗口的所有时间戳（俗称：做 Batch），以保证分配性能。对于客户端的请求，PD 允许请求多个事件戳，以减少网络负载，提高性能。</p>
<p>PD 每一段时间都会请求 etcd，推进物理时钟。当前物理事件戳下逻辑时钟即将耗尽或已经耗尽时，也会推进物理时钟。</p>
<p>PD Leader 不可用时，会选举出新的 Leader，选举期间系统会有一小段时间不可用，这也是 TSO 中心授时带来的小问题。不过 PingCAP 表示，实际使用上 TSO 这些问题并没有造成过什么不可忽视的影响。</p>
<h2 id="逻辑时钟（Logical-Clock）"><a href="#逻辑时钟（Logical-Clock）" class="headerlink" title="逻辑时钟（Logical Clock）"></a>逻辑时钟（Logical Clock）</h2><p>前面提到了 Lamport 联系到了狭义相对论，认为在物理时钟下讨论事件的序是有很大问题的，直接给了 Lamport 一个如何追踪分布式系统中时间序的启发，另一个角度出发，于是就有了最早的逻辑时钟算法，Lamport 时钟。</p>
<h3 id="Lamport-时钟"><a href="#Lamport-时钟" class="headerlink" title="Lamport 时钟"></a>Lamport 时钟</h3><p><img src= "/img/loading.gif" data-src="/img/space-time1.svg" alt="时序图1"></p>
<blockquote>
<p>There is only a partial order in which an event <em>e1</em> precedes an event <em>e2</em> iff <em>e1</em> can causally affect <em>e2</em>.  —- Leslie Lamport</p>
</blockquote>
<p>Lamport 认为，时空中没有不变的事件全序关系，只有因为事件间相互影响造成因果关系，从而有事件的偏序。在上面的系统时序图中，我们从抽象视角上，引入一个时钟，仅仅通过赋予发生的事件一个简单的数字去追踪事件关系。可以认为这个简单的数字，其实就是事件发生的一个时刻值。为了更精确描述这个算法，我们为每一个进程定义： $C_i$是进程 $i$ 的时钟，$C_i\langle E \rangle$ 指事件 $E$ 在进程 $i$ 的发生时刻值。注意到，这个时刻值与物理时间是没有任何联系的，所以我们定义的时钟是个<strong>逻辑时钟（Logical Clock）</strong>，我们可以抛开一切物理计时的方法，通过<strong>计数器（Counter）</strong>去实现它。</p>
<p>进一步，我们想一想怎么实现这个时钟才是正确的，或者说这个时钟应该满足什么性质或条件。我们想用这个时钟去追踪事件间的 happened-before 关系，很明显我们需要这样一个条件：</p>
<ul>
<li>Clock Condition：$\forall\text{ Event }A,B: (A \rightarrow B) \Rightarrow (C \langle A \rangle \lt C\langle B \rangle)$</li>
</ul>
<p>注意，这里仍然是 $\Rightarrow$，不是 $\Leftrightarrow$。这样的条件可以进一步推出满足的两个条件：</p>
<ul>
<li>Clock Condition C1：$\forall\text{ Event }A,B \text{ in Process } P_i : (A \rightarrow B) \Rightarrow (C_i \langle A \rangle \lt C_i\langle B \rangle) $</li>
<li>Clock Condition C2：对于消息 $M$， $A$ 是其在进程 $P_i$ 的发送事件， $B$ 是其在进程 $P_j$ 的发送事件，那么 $C_i \langle A \rangle \lt C_j\langle B \rangle$。</li>
</ul>
<p>为了让时钟满足上面的条件，我们用例子来说明。我们在保留 happened-before 关系，且满足 Clock Condition 前提下画上等时线，越过等时线，时钟则必须向前<strong>跳变（Tick）</strong>：</p>
<p><img src= "/img/loading.gif" data-src="/img/space-time1-lined.svg" alt="等时时序图"></p>
<p>然后我们把等时线拉平，重新观察时序图：</p>
<p><img src= "/img/loading.gif" data-src="/img/space-time1-flatten.svg" alt="拉平等时线的时序图"></p>
<p>我们很容易可以得到算法：</p>
<ul>
<li>Implementation Rule 1：同一进程，在顺序两个事件发生的期间，时钟会向前跳变。</li>
<li>Implementation Rule 2(a)：任意发送事件 $A$ 包含了一个时间戳 $T_m = C_i\langle A \rangle$。</li>
<li>Implementation Rule 2(b)：接收到任意事件 $B$ ，进程 $j$ 会将自身时钟设定为不小于消息事件戳 $T_m$ 的值。</li>
</ul>
<p>Implementation Rule 1 保证了 Clock Condition C1，Implementation Rule 2(a) 和 Implementation Rule 2(b) 保证了 Clock Condition C2。它们共同保证了逻辑时钟满足 Clock Condition。</p>
<p>按照 $ C \langle A \rangle \lt C\langle B \rangle $ 这种关系给出的偏序，有可能把并发事件的 happened-before 关系搞错（比如时序图中的 $C_2$ 和 $B_3$），但因为并发事件没有数据交互，某些情况下并无大碍。整个分布式系统一定会达成事件因果上的一致，比如按照时间戳顺序去执行具有 happened-before 关系一组写操作事件，写操作一定不会乱序。</p>
<h4 id="人为定义的全序"><a href="#人为定义的全序" class="headerlink" title="人为定义的全序"></a>人为定义的全序</h4><p>任意一个进程，通过比较时间戳给出的是偏序关系，因为我们遇到 $ C \langle A \rangle = C\langle B \rangle $ 的时候，就没法比较了。当然有时候为了在全局范围内取得全序，达成一致，我们可以罔顾外部观察的事实，人为定义全序：</p>
<script type="math/tex; mode=display">
A \rightsquigarrow B \equiv (C_i \langle A \rangle \lt C_j\langle B \rangle ) \lor (C_i \langle A \rangle = C_j\langle B \rangle \land P_i \prec P_j)</script><p>在时间戳相等时，我们认为进程序号比较大的事件发生在进程序号小的事件之后，这个是人为定义的全序，并不为了反映外部观察的客观事实，而仅仅是一种约定。我们也可以用其他约定来定义全序。但在这里的定义下，明显有：</p>
<script type="math/tex; mode=display">
A \rightarrow B \Rightarrow A \rightsquigarrow B</script><p>信息更弱了。实际上，因果关系并没有被破坏。人为定义全序有助于分布式系统操作上取得全局一致，虽然这一结果有时候并不符合外部观察的规律。</p>
<p>Lamport 时钟算法并不是一种实现分布式一致性算法，只是一种用来确定因果一致的事件序的想法。类似对同一资源操作造成冲突的并发事件，Lamport 时间戳无法作出区分，也就无法进一步解决冲突。</p>
<h3 id="向量时钟（Vector-Clock）"><a href="#向量时钟（Vector-Clock）" class="headerlink" title="向量时钟（Vector Clock）"></a>向量时钟（Vector Clock）</h3><p>对于两个事件 $A$、$B$，Lamport 时钟下观测到的结果 $C \langle A \rangle \lt C\langle B \rangle$，给出的信息非常有限。有时候希望有更强的Clock Condition：</p>
<script type="math/tex; mode=display">
\forall\text{ Event }A,B: (A \rightarrow B) \Leftrightarrow (C \langle A \rangle \lt C\langle B \rangle)</script><p>这样我们能够准确的确定 happened-before 关系，并且准确确定出哪些事件之间是并发的。我们想知道为什么时间戳不能用来反推事件的 happened-before 关系，<del>辗转反侧</del>终于找到了原因。本质是我们没有区分不同进程的时钟，从而导致了信息的丢失。比如进程 $i$ ，$j$ 在某一个时间段内时钟达成了一致（$C_i = C_j$），此时 $i$ 发生了事件，推进了时钟，导致了 $(C \langle A \rangle \lt C\langle B \rangle) \Rightarrow (A \rightarrow B) $ 的反例的出现，关系便不再成立了。我们的想法是，将各个进程的时钟分开，这个便是<strong>向量时钟（Vector Clock）</strong>。</p>
<p>为了实现更强的 Clock Condition，单独维护每个进程的时钟，使得 $C_i$ 从一个值变成了一个向量：</p>
<script type="math/tex; mode=display">
C_i = [c_1,c_2,c_3,...,c_n]</script><p>跟逻辑时钟一样，我们可以定义算法规则：</p>
<ul>
<li>Rule 1：同一进程，在顺序两个事件发生的期间，时钟向量中自身时钟会向前跳变，其他维持原状。</li>
<li>Rule 2a：任意发送事件 $A$ 包含了向量时间戳 $T_m = C_i\langle A \rangle$。</li>
<li>Rule 2b：接收到任意事件 $B$ ，进程 $j$ 根据消息的向量事件戳 $T_m$，更新本地时间向量，使得本地向量所有时钟分量不小于事件戳向量对应的时钟分量。</li>
</ul>
<p>我们定义时间戳比较的规则：</p>
<script type="math/tex; mode=display">
C(A) < C(B) \equiv  (\exists i \in \mathbb{N}:C(A)[i] < C(B)[i]) \land ( \forall i \in \mathbb{N}:C(A)[i] \le C(B)[i])</script><p>即对于 $C(A) &lt; C(B)$，要求 $A$ 事件所有时钟分量都小于或等于 $B$ 事件对应分量，且至少有一个分量小于 $B$ 事件的对应分量。</p>
<p>不满足 $C(A) &lt; C(B)$ 的事件相互都是并发事件。</p>
<p>通过比较时间戳，<strong>向量时钟可以准确观测事件的 happened-before 关系，准确给出因果关系确定的事件偏序</strong>。这个性质使得使用向量时间戳可以严格区分出并发事件。</p>
<p><img src= "/img/loading.gif" data-src="/img/conflict-detect.svg" alt="事件冲突"></p>
<p>上面的时序图中有两个冲突的并发事件 $Set(A,2)$ 和 $Del(A)$。紫色是 Lamport 时间戳，绿色的是向量时间戳。</p>
<p>如采用 Lamport 时钟，那么 <script type="math/tex">C(E_{Del(A)}) = 5</script>， <script type="math/tex">C(E_{Set(A,2)}) = 3</script>，如果不改进算法，则无法分辨出两个操作是并发冲突的。</p>
<p>在向量时钟下，<script type="math/tex">C(E_{Del(A)}) = [1,5,2]</script>， <script type="math/tex">C(E_{Set(A,2)}) = [2,2,3]</script>，可以判断两个操作是并发事件。</p>
<p>向量时钟不足的地方是 Timestamp 的 Overhead：在节点很多的时候，向量维度会非常的高，占用很多空间。（想象一下，我们仅仅想传递一个 8 位的 intager，在512台机器的集群里，假设时间戳32位，我们要带上 2kB 的时间戳）</p>
<h3 id="混合逻辑时钟（HLC，Hybird-Logical-Clock）"><a href="#混合逻辑时钟（HLC，Hybird-Logical-Clock）" class="headerlink" title="混合逻辑时钟（HLC，Hybird Logical Clock）"></a>混合逻辑时钟（HLC，Hybird Logical Clock）</h3><blockquote>
<p>Time is an illusion. —- Albert Einstein</p>
</blockquote>
<p>物理时钟不好记录 happened-before 关系，逻辑时钟又有点太理论化了。年复一年，人们端详着 Lamport 时钟，面对着现实不太给力的 NTP 协议，想找到一种折中一点的工程办法。终于在 2014 年，提出了一种将理论和现实结合在一起的时钟，<strong>混合逻辑时钟（HLC，Hybird Logical Clock）</strong>。HLC 既可以跟逻辑时钟一样追踪 happened-before 关系，又能逼近物理时钟。</p>
<p>对于任意一个事件 $E$ ，HLC 使用两段时间戳：物理时间戳 $E.l$、逻辑事件戳 $E.c$。它们共同组成时间戳 $E.hlc = \langle E.l, E.c \rangle$。对于时间戳的比较：</p>
<script type="math/tex; mode=display">
A.hlc < B.hlc \equiv (A.l < B.l) \lor (A.l = B.l \land A.c < B.c)</script><p>以下是 HLC 想达到的效果：</p>
<ul>
<li>$A \rightarrow B \Rightarrow A.hlc &lt; B.hlc$，其中 $l$ 是事件的时间戳（Timestamp）。</li>
<li>时间戳仅仅占用 $O(1)$ 空间。</li>
<li>物理时间戳部分与事件实际发生时间的误差是有界的，即 $|E.l - E.pt| &lt; \epsilon $，$E.pt$ 是事件 $E$ 发生时本地的物理时间。</li>
</ul>
<p>HLC 算法与 Lamport 时钟算法有点相似。规则是这样的：</p>
<ul>
<li><p>每一个进程（记为$j$）在本地维护一个混合逻辑时间戳，初值 $j.hlc = \langle 0, 0 \rangle$</p>
</li>
<li><p><strong>对于发生新事件，总是保证本地时间戳比已知的时间戳要新</strong>，这里根据消息类型采用不同的算法：</p>
<ul>
<li><p>对于自发事件或发送事件：</p>
<script type="math/tex; mode=display">
\begin{align}
&j.l' = j.l;\\
&j.l = max(j.l', j.pt);\\
& \text{If } (j.l == j.l') \text{ then } j.c = j.c + 1\\
&\text{ else } j.c = 0;
\end{align}</script></li>
<li><p>对于接收事件 $M$ ：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
&j.l' = j.l;\\
&j.l = max(j.l', j.pt, M.l);\\
&\text{If }(j.l==j.l' \land j.l'==M.l) \text{ then } j.c = max(j.c, M.c)\\
&\text{ Else If }(j.l==j.l') \text{ then } j.c = j.c + 1 \\
&\text{ Else If }(j.l == M.l) \text{ then } j.c = M.c + 1\\
&\text{ Else } j.c = 0;
\end{align}</script></li>
<li><p>发生的新事件打上<strong>更新后</strong>的本地时间戳。</p>
</li>
<li><p>在同一节点的满足 $E.l &lt; F.l$  的两个事件 $E$、$F$ 中间，引入自发的 <strong> Virtual Dummy 事件</strong> $L$，满足 $L.l \in [E.l + 1, F.l] \land L.c = 0$。</p>
</li>
</ul>
<p>HLC 满足以下的几个定理：</p>
<ul>
<li><p>两个事件 $E$、$F$，满足 $E \rightarrow F \Rightarrow E.hlc &lt; F.hlc$。</p>
</li>
<li><p>对于任意一个事件 $F$：</p>
<ul>
<li><p>$F.l \ge F.pt$</p>
</li>
<li><p>$F.l &gt; F.pt \Rightarrow (\exists \text{ Event } G:G \rightarrow F \land G.pt = F.l)$</p>
</li>
<li><p>物理时钟误差有界：$|F.l - F.pt| \le \epsilon $，$\epsilon$ 是时钟同步的 Uncertainty。</p>
</li>
<li><p>逻辑时间的跳变一定是由因果事件引起的，在全局一定存在着一系列事件：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
  F.c = k \land k > 0 \Rightarrow (\exists &\text{ Event } G_1,G_2,...,G_k: \\
  &(\forall i \in [1,k) : G_i \rightarrow G_{i+1}) \\
  \land & (\forall j \in [1,k] : G_j.l = F.l) \\
  \land & G_k \rightarrow F)
  \end{align}</script><ul>
<li>除去 Virtual Dummy 事件，$F.c \le |{\text{Event } G: G \rightarrow F \land G.l = F.l}|$</li>
<li>逻辑时间戳不会无限增长：$F.c \le N*(\epsilon + 1)$<ul>
<li>若本地物理时钟在消息传递期间，一定会增长 $d$，那么逻辑时间戳最大不超过 $\frac{\epsilon}{d} + 1$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一堆公式看起来比较头大。笔者对 HLC 了解不算深，证明就不放这里了，所以感兴趣的话可以参考论文<a href="https://cse.buffalo.edu/tech-reports/2014-04.pdf" target="_blank" rel="noopener">《Logical Physical Clocks and Consistent Snapshots in Globally Distributed Databases》</a>。应用上，CockroachDB、MongoDB 都在使用 HLC 作为时间戳方案。</p>
<h4 id="自稳定问题"><a href="#自稳定问题" class="headerlink" title="自稳定问题"></a>自稳定问题</h4><p>采用 HLC 的系统里，如果有时间不正常的节点，可能会把整个系统所有节点的本地物理时间戳都推进到一个非常大的值。在 HLC 下，逻辑时间的重置，要求物理时间向前推进，若物理时钟长期赶不上本地的物理时间戳，带来的就是逻辑时间戳的无限增长，从而某种意义上打破了 HLC 的几个有界性定理。论文给出的可能的做法是：</p>
<ul>
<li>一旦发现某个 Message 的物理时间戳大大超越了本地时间，则把这样的 Message 丢弃，因为节点两方，有一方的时钟可能已经出问题了，同时也记录下相关日志，触发告警。</li>
<li>限制逻辑时间戳 $c$ ，让其不能无限增长。</li>
</ul>
<h4 id="全局一致性快照（Globally-Consistent-Snapshots）"><a href="#全局一致性快照（Globally-Consistent-Snapshots）" class="headerlink" title="全局一致性快照（Globally Consistent Snapshots）"></a>全局一致性快照（Globally Consistent Snapshots）</h4><p>假设我们需要读 $t = 10$ 时刻的快照。因为时钟同步全局时间误差在 $\epsilon$ ，在 $\epsilon$ 时间内，全局每一个节点都将产生一个 $\langle 10, 0 \rangle$ 的 Dummy 事件作为分隔。分隔使得一切事件将会发生在这个 Dummy 事件之后，不可能再产生时间戳在 $\langle 10, 0 \rangle$ 之前的事件，也就是系统在 $t = 10$ 一定会有一个全局的快照。除此我们也可以给所有节点广播一个消息，使得分隔事件提前产生。</p>
<h4 id="HLC-的优势"><a href="#HLC-的优势" class="headerlink" title="HLC 的优势"></a>HLC 的优势</h4><p>NTP 同步下的物理时钟，可能会被其更新到一个更早的时间，以此生成的时间戳并不满足严格单调增长。HLC 时钟虽然使用 NTP 同步下的物理时钟作为时钟源，但其物理时间部分一定是保证严格单调增长的，且 HLC 的理论上的某些性质，使得 HLC 的时钟漂移量比 NTP 的时钟漂移量要小。由此，HLC 可以说继承了物理时钟的优点，且克服了 NTP 下同步时钟的某些缺陷，是一种很不错改良的方案。HLC 足以成为物理时钟的一种替代方案。</p>
<p>除此之外，HLC 作为逻辑时钟的一种改进，能够捕捉事件的因果关系，继承了逻辑时钟的优点，所以也足以替代一般的逻辑时钟。</p>
<p>可以说 HLC 是一种目前来说比较有效的，生成时间戳的方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我用这篇长文梳理了分布式系统中，关于时间、时钟、时序、事件顺序的相关问题。主要探讨了事件因果、顺序，还有分布式系统常见的时钟解决方案。时钟解决方案包括物理时钟和逻辑时钟两类，包含了目前工程上的主要实现方案。明确了时序问题之后，我们才能更易于理解和讨论分布式系统的共识（Consensus）和一致性（Consistency）等其他问题。一致性问题跟时序有很强的相关性，因为时间有限的缘故，可能只能之后再在本文补充了。</p>
<h1 id="参考文献-References"><a href="#参考文献-References" class="headerlink" title="参考文献 References"></a>参考文献 References</h1><ul>
<li><a href="https://asktug.com/t/topic/2026" target="_blank" rel="noopener">PD的时钟服务——TSO</a></li>
<li><a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf" target="_blank" rel="noopener">《Time, Clocks, and the Ordering of Events in a Distributed System》</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">《Spanner: Google’s Globally-Distributed Database》</a></li>
<li><a href="https://cse.buffalo.edu/tech-reports/2014-04.pdf" target="_blank" rel="noopener">《Logical Physical Clocks and Consistent Snapshots in Globally Distributed Databases》</a></li>
<li><a href="https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">《The Part-time Parliament》</a></li>
<li><a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a></li>
<li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">《In Search of an Understandable Consensus Algorithm (Extended Version)》</a></li>
<li><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf" target="_blank" rel="noopener">《CONSENSUS: BRIDGING THEORY AND PRACTICE》</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chad Mai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.sunmxt.cn/2020/07/24/time-clocks-events/">http://blog.sunmxt.cn/2020/07/24/time-clocks-events/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><div class="post_share"><div class="social-share" data-image="/img/space-time1.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/02/begin-maybe/"><img class="next-cover" data-src="/img/tagong_sunset.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Begin? Maybe.</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'zV3FAEAGBhQcYjNT30c3LJ8I-gzGzoHsz',
  appKey: '4MwJSd2zKkx2FpUrGIcd7isf',
  placeholder: '说点什么吧？',
  avatar: 'identicon',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Chad Mai</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>